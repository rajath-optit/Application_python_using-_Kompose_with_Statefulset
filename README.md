# Microservice communication with RabbitMQ using compose
To convert your Docker Compose setup to Kubernetes StatefulSets using `kompose`, follow these steps:

1. **Install Kompose**: Ensure you have `kompose` installed. You can install it via the following command:
    ```sh
    curl -L https://github.com/kubernetes/kompose/releases/download/v1.25.0/kompose-linux-amd64 -o kompose
    chmod +x kompose
    sudo mv ./kompose /usr/local/bin/kompose
    ```

2. **Convert Docker Compose to Kubernetes**:
    Run the `kompose` command to convert your `docker-compose.yml` to Kubernetes manifests.
    ```sh
    kompose convert -f docker-compose.yml
    ```

    This will generate a set of YAML files for Kubernetes resources.

3. **Modify the Generated Kubernetes Manifests**:
    Open the generated YAML files and modify them as needed. Specifically, convert the relevant deployments to StatefulSets.

4. **Apply the Kubernetes Manifests**:
    Apply the generated and modified Kubernetes manifests using `kubectl`.
    ```sh
    kubectl apply -f <generated-file>.yaml
    ```

Here's an example of what you might need to adjust in the generated files:

### 1. Convert Deployments to StatefulSets

For services that require persistent storage, such as MySQL, you should convert the generated Deployment to a StatefulSet. Here's an example:

**mysql_db-deployment.yaml** (generated by kompose):
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql-db
spec:
  selector:
    matchLabels:
      app: mysql-db
  serviceName: mysql
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql-db
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_DATABASE
          value: "ims"
        - name: MYSQL_ROOT_PASSWORD
          value: "pesuims"
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: mysql-persistent-storage
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
```

### 2. Ensure Persistent Volumes and Claims

Ensure the Persistent Volume Claims are correctly defined in the generated YAML. For example:

**mysql-db-claim0-persistentvolumeclaim.yaml**:
```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-persistent-storage
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

### 3. Services

Ensure that services are correctly defined to expose the StatefulSets:

**mysql-db-service.yaml**:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-db
spec:
  ports:
    - port: 3306
  selector:
    app: mysql-db
  clusterIP: None
```

### 4. Deployment for Stateless Applications

The producer and consumers can remain as Deployments, since they do not require persistent storage. Here is an example for the producer:

**producer-deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: producer
spec:
  replicas: 1
  selector:
    matchLabels:
      app: producer
  template:
    metadata:
      labels:
        app: producer
    spec:
      containers:
      - name: producer
        image: <your-registry>/producer:latest
        ports:
        - containerPort: 5000
        env:
        - name: RABBITMQ_HOST
          value: rabbitmq
        - name: RABBITMQ_PORT
          value: "5672"
        - name: RABBITMQ_USERNAME
          value: guest
        - name: RABBITMQ_PASSWORD
          value: guest
```

Repeat similar steps for all other microservices (consumers).

5. **Applying the Manifests**:
    Finally, apply all the generated and modified manifests:
    ```sh
    kubectl apply -f .
    ```

This setup ensures that your MySQL database runs as a StatefulSet with persistent storage, while other services run as Deployments. Adjustments might be necessary depending on the specifics of your setup and requirements.
